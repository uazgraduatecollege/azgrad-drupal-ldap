<?php

/**
 * @file
 * Module for the LDAP User Entity.
 */

use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\ldap_servers\OrphanProcessor;
use Drupal\ldap_servers\Processor\TokenProcessor;
use Drupal\ldap_user\Helper\LdapConfiguration;
use Drupal\ldap_user\Processor\DrupalUserProcessor;
use Drupal\ldap_user\Processor\LdapUserProcessor;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Form\FormState;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Url;

/**
 * Implements hook_cron().
 */
function ldap_user_cron() {
  $check_orphans = \Drupal::config('ldap_user.settings')->get('ldap_user_conf.orphanedDrupalAcctBehavior');
  if ($check_orphans != 'ldap_user_orphan_do_not_check') {
    $processor = new OrphanProcessor();
    $result = $processor->checkOrphans();
    if ($result !== TRUE) {
      \Drupal::logger('ldap_user')->error('Check for orphaned LDAP provisioned Drupal accounts failed.');
    }
  }
}

/**
 * Implements hook_mail().
 */
function ldap_user_mail($key, &$message, $params) {
  switch ($key) {
    case 'orphaned_accounts':
      $message['subject'] = \Drupal::config('system.site')->get('name') . ' ' . t('Orphaned LDAP Users');
      $message['body'][] = t('The following %count Drupal users no longer have corresponding LDAP Entries. Perhaps they have been removed from the LDAP and should be removed from your site.',
          ['%count' => count($params['accounts'])]
        );
      $message['body'][] .= "\n" . t('username,mail,edit url') . "\n" . join("\n", $params['accounts']);
      break;
  }
}

/**
 * Implements hook_ldap_attributes_needed_alter().
 */
function ldap_user_ldap_attributes_needed_alter(&$attributes, $params) {
  $processor = new DrupalUserProcessor();
  $attributes = $processor->alterUserAttributes($attributes, $params);
}

/**
 * Implements hook_ldap_user_attrs_list_alter().
 */
function ldap_user_ldap_user_attrs_list_alter(&$available_user_attrs, &$params) {
  $processor = new DrupalUserProcessor();
  list($available_user_attrs, $params) = $processor->alterLdapUserAttributes($available_user_attrs, $params);
}

/**
 * Implements hook_help().
 */
function ldap_user_help($route_name, RouteMatchInterface $route_match) {
  $ldap_user_help = t('LDAP user configuration determines how and when
     Drupal accounts are created based on LDAP data and which user fields
     are derived and synced to and from LDAP. See @helplink.',
    array(
      '@helplink' => \Drupal::l('the drupal.org handbook page', Url::fromUri('http://drupal.org/node/997082')),
    ));

  switch ($route_name) {
    case 'help.page.ldap_user':
    case 'ldap_user.admin_form':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . $ldap_user_help . '</p>';
      return $output;
  }
}

/**
 * Implements hook_user_login().
 */
function ldap_user_user_login($account) {
  $processor = new DrupalUserProcessor();
  $processor->drupalUserLogsIn($account);
}

/**
 * Implements hook_ENTITY_TYPE_insert().
 */
function ldap_user_user_insert($account) {
  $processor = new DrupalUserProcessor();
  $processor->newDrupalUserCreated($account);
}

/**
 * Implements hook_ENTITY_TYPE_update().
 */
function ldap_user_user_update($account) {
  $processor = new DrupalUserProcessor();
  $processor->drupalUserUpdated($account);
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function ldap_user_user_presave($account) {
  $processor = new DrupalUserProcessor();
  $processor->drupalUserPreSave($account);
}

/**
 * Implements hook_ENTITY_TYPE_delete().
 */
function ldap_user_user_delete($account) {
  $processor = new DrupalUserProcessor();
  $processor->drupalUserDeleted($account);
}

/**
 * Implements hook_entity_base_field_info().
 */
function ldap_user_entity_base_field_info(EntityTypeInterface $entity_type) {
  if ($entity_type->id() == 'user') {
    $fields = [];

    $fields['ldap_user_puid_sid'] = BaseFieldDefinition::create('string')
      ->setLabel(t('LDAP server ID'))
      ->setDescription(t('Server ID  that PUID was derived from. NULL if PUID is independent of server configuration instance.'));

    $fields['ldap_user_puid'] = BaseFieldDefinition::create('string')
      ->setLabel(t('Permanent unique ID'))
      ->setDescription(t('The user\'s permanent unique ID should never change for a given ldap identified user.'));

    $fields['ldap_user_puid_property'] = BaseFieldDefinition::create('string')
      ->setLabel(t('PUID base property'))
      ->setDescription(t('The LDAP property used for the PUID, for example "dn".'));

    $fields['ldap_user_current_dn'] = BaseFieldDefinition::create('string')
      ->setLabel(t('LDAP DN'))
      ->setDescription(t('The user\'s LDAP DN. May change when user\'s DN changes.'));

    $fields['ldap_user_prov_entries'] = BaseFieldDefinition::create('string')
      ->setLabel(t('Provisioned LDAP entries'))
      ->setCardinality(FieldStorageDefinitionInterface::CARDINALITY_UNLIMITED);

    $fields['ldap_user_last_checked'] = BaseFieldDefinition::create('timestamp')
      ->setLabel(t('Last LDAP comparison'))
      ->setDescription(t('Unix timestamp of when Drupal user was compared to ldap entry. This could be for purposes of syncing, deleteing drupal account, etc.'));

    $fields['ldap_user_ldap_exclude'] = BaseFieldDefinition::create('boolean')
      ->setLabel(t('Exclude from LDAP'))
      ->setDescription(t('Whether to exclude the user from LDAP functionality.'));

    return $fields;
  }
}

// Below are form hooks which cannot be easily moved.

/**
 * Implements hook_form_FORM_ID_alter(). for user_login_block.
 */
function ldap_user_form_user_login_block_alter(&$form, &$form_state) {
  array_unshift($form['#validate'], 'ldap_user_grab_password_validate');
}

/**
 * Implements hook_form_FORM_ID_alter(). for user_login_form.
 */
function ldap_user_form_user_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  array_unshift($form['#validate'], 'ldap_user_grab_password_validate');
}

/**
 * Implements hook_form_FORM_ID_alter(). for user_register_form.
 */
function ldap_user_form_user_profile_form_alter(&$form, $form_state) {
  array_unshift($form['#submit'], 'ldap_user_grab_password_validate');
}

/**
 * Implements hook_form_FORM_ID_alter(). for password_policy_password_tab.
 */
function ldap_user_form_password_policy_password_tab_alter(&$form, &$form_state) {
  array_unshift($form['#validate'], 'ldap_user_grab_password_validate');
}

/**
 * Store password from logon forms in ldap_user_ldap_provision_pwd static variable
 * for use in provisioning to LDAP.
 */
function ldap_user_grab_password_validate($form, FormState &$form_state) {
  // This is not a login form but profile form and user is insertingpassword to update email.
  if (!empty($form_state->getValue('current_pass_required_values'))) {
    if (!empty($form_state->getValue('current_pass')) && empty($form_state->getValue('pass'))) {
      TokenProcessor::passwordStorage('set', $form_state->getValue('current_pass'));
    }
  }
  // Otherwise a logon form.
  elseif (!empty($form_state->getValue('pass'))) {
    TokenProcessor::passwordStorage('set', $form_state->getValue('pass'));
  }
}

/**
 * Implements hook_form_FORM_ID_alter(). for user_register_form.
 */
function ldap_user_form_user_register_form_alter(&$form, $form_state) {

  array_unshift($form['#submit'], 'ldap_user_grab_password_validate');

  if (!\Drupal::currentUser()->hasPermission('administer users')) {
    return;
  }

  $ldap_fieldset = [];
  $ldap_fieldset['ldap_user_association'] = [
    '#type' => 'radios',
    '#options' => [
      LdapConfiguration::$manualAccountConflictLdapAssociate => t('Make this an LDAP associated account.'),
      LdapConfiguration::$manualAccountConflictNoLdapAssociate => t('Do not make this an LDAP associated account.'),
    ],
    '#default_value' => LdapConfiguration::$manualAccountConflictNoLdapAssociate,
    '#description' => t('If a related LDAP account can not be found, a validation error will appear and the account will not be created.'),
    '#title' => t('LDAP Entry Association.'),
  ];

  if (LdapConfiguration::provisionAvailableToLDAP(LdapConfiguration::$provisionDrupalUserOnUserUpdateCreate)) {
    $ldap_fieldset['ldap_user_association']['#disabled'] = TRUE;
    $ldap_fieldset['ldap_user_association']['#description'] = t('Since "Create
      or Sync to Drupal user anytime a Drupal user account is created or updated"
      is selected at admin/config/people/ldap/user, this option will have no
      effect so its disabled.');
  }
  elseif (\Drupal::config('ldap_user.settings')->get('ldap_user_conf.manualAccountConflict') != LdapConfiguration::$manualAccountConflictShowOptionOnForm) {
    $ldap_fieldset['ldap_user_association']['#disabled'] = TRUE;
    $ldap_fieldset['ldap_user_association']['#description'] = t('To enable
      this an LDAP server must be selected for provisioning to Drupal in
      admin/config/people/ldap/user and "Show option on user create form..." must be selected.');
  }

  $ldap_fieldset['ldap_user_create_ldap_acct'] = array(
    '#type' => 'checkbox',
    '#title' => t('Create corresponding LDAP entry.'),
  );
  if (!LdapConfiguration::provisionAvailableToLDAP(LdapConfiguration::$provisionDrupalUserOnAllowingManualCreation)) {
    $ldap_fieldset['ldap_user_create_ldap_acct']['#disabled'] = TRUE;
    $ldap_fieldset['ldap_user_create_ldap_acct']['#description'] = t('To enable
      this an LDAP server must be selected for provisioning to Drupal in
      admin/config/people/ldap/user and manual creation of LDAP accounts
      must be enabled also.');
  }

  if (count($ldap_fieldset) > 0) {
    $form['ldap_user_fields'] = $ldap_fieldset;
    $form['ldap_user_fields']['#type'] = 'fieldset';
    $form['ldap_user_fields']['#title'] = t('LDAP Options');
    $form['ldap_user_fields']['#collapsible'] = TRUE;
    $form['ldap_user_fields']['#collapsed'] = FALSE;
  }

  $form['#validate'][] = 'ldap_user_form_register_form_validate';
  foreach (array_keys($form['actions']) as $action) {
    if (isset($form['actions'][$action]['#type']) && $form['actions'][$action]['#type'] == 'submit') {
      $form['actions'][$action]['#submit'][] = 'ldap_user_form_register_form_submit2';
    }
  }

}

/**
 * Implements hook_form_validate().
 */
function ldap_user_form_register_form_validate($form, FormStateInterface &$form_state) {
  $config = \Drupal::config('ldap_user.settings');

  if ($form_state->getValue('ldap_user_association') == LdapConfiguration::$manualAccountConflictNoLdapAssociate) {
    $form_state->set('ldap_user_ldap_exclude', 1);
  }
  $factory = \Drupal::service('ldap.servers');

  /**
   * If corresponding LDAP account does not exist and provision not selected
   * and make ldap associated is selected, throw error.
   */
  if (!$form_state->getValue('ldap_user_create_ldap_acct') &&
    $form_state->getValue('ldap_user_association') == LdapConfiguration::$manualAccountConflictLdapAssociate) {
    if (empty($config->get('ldap_user_conf.drupalAcctProvisionServer'))) {
      $form_state->setErrorByName('ldap_user_missing_', t('The provisioning server is not set up correctly.'));
      \Drupal::logger('ldap_user')->error('No server available for provisioning to Drupal.');
    }
    else {
      $ldap_user = $factory->getUserDataFromServerByIdentifier($form_state->getValue('name'), $config->get('ldap_user_conf.drupalAcctProvisionServer'), 'ldap_user_prov_to_drupal');
      if (!$ldap_user) {
        $form_state->setErrorByName('ldap_user_association', t(
            'User %name does not have a corresponding LDAP Entry (dn). Under LDAP options, you may NOT select "Make this an LDAP Associated Account"',
            ['%name' => $form_state->getValue('name')])
        );
      }
    }
  }

  // If trying to provision an LDAP account and one already exists, throw error.
  if ($form_state->getValue('ldap_user_create_ldap_acct')) {
    if (empty($config->get('ldap_user_conf.ldapEntryProvisionServer'))) {
      $form_state->setErrorByName('ldap_user_missing_', t('The provisioning server is not set up correctly.'));
      \Drupal::logger('ldap_user')->error('No server available for provisioning to LDAP.');
    }
    else {
      $ldap_user = $factory->getUserDataFromServerByIdentifier($form_state->getValue('name'), $config->get('ldap_user_conf.ldapEntryProvisionServer'), 'ldap_user_prov_to_ldap');
      if ($ldap_user) {
        $form_state->setErrorByName(
          'ldap_user_create_ldap_acct', t(
            'User %name already has a corresponding LDAP Entry (%dn). Uncheck "Create corresponding LDAP entry" to allow this Drupal user to be created. Select "Make this an LDAP associated account" to associate this account with the ldap entry.',
            ['%dn' => $ldap_user['dn'], '%name' => $form_state->getValue('name')])
        );
      }
    }
  }

}

/**
 * Called after user_register_form_submit .
 **/
function ldap_user_form_register_form_submit2(&$form, FormState $form_state) {
  // It's only called when a user who can create a new user does so using the register form.
  $values = $form_state->getValues();
  $ldap_user_association_set = FALSE;

  // Create LDAP account?
  if (@$values['ldap_user_create_ldap_acct']) {
    if ($account = user_load_by_name($values['name'])) {
      $ldapProcessor = new LdapUserProcessor();
      $ldap_provision_entry = $ldapProcessor->getProvisionRelatedLdapEntry($account);
      // Does the LDAP user exist? If not then create it.
      if (!$ldap_provision_entry) {
        $provision_result = $ldapProcessor->provisionLdapEntry($account);
      }
      // If so then associate it.
      else {
        $ldap_user_association_set = TRUE;
      }
    }
    else {
      // don't do anything here.  If account is not created, other user module warnings will exist.
    }
  }

  $userProcessor = new DrupalUserProcessor();
  if ($values['ldap_user_association'] == LdapConfiguration::$manualAccountConflictNoLdapAssociate) {
    $userProcessor->ldapExcludeDrupalAccount($values['name']);
  }
  elseif ($ldap_user_association_set ||
    @$values['ldap_user_association'] == LdapConfiguration::$manualAccountConflictLdapAssociate ||
    \Drupal::config('ldap_user.settings')->get('ldap_user_conf.manualAccountConflict') == LdapConfiguration::$manualAccountConflictLdapAssociate) {
    // Either LDAP provision (above) has said "associate" or the person creating
    // the account has said "associate" or the LDAP user settings says
    // "Associate manually created Drupal accounts with related LDAP Account if one exists.".
    $userProcessor->ldapAssociateDrupalAccount($values['name']);
  }

}
